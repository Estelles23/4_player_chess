<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>4-Player Chess</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Fira+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        :root {
            --red: #c0392b;
            --red-light: #e74c3c;
            --blue: #2980b9;
            --blue-light: #3498db;
            --green: #27ae60;
            --green-light: #2ecc71;
            --yellow: #f39c12;
            --yellow-light: #f1c40f;
            --board-light: #f5e6d3;
            --board-dark: #b58863;
            --bg-dark: #1a1a2e;
            --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --gold: #d4af37;
            --highlight: rgba(255, 215, 0, 0.5);
            --valid-move: rgba(100, 255, 100, 0.4);
        }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        body {
            font-family: 'Fira Sans', sans-serif;
            background: var(--bg-gradient);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
        }

        h1 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(212, 175, 55, 0.3);
            letter-spacing: 0.1em;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 95vmin;
        }

        .turn-indicator {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-badge {
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 0.9rem;
            opacity: 0.5;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-badge.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .player-badge.eliminated {
            opacity: 0.3;
            text-decoration: line-through;
        }

        .player-badge.red { background: var(--red); color: white; border-color: var(--red-light); }
        .player-badge.blue { background: var(--blue); color: white; border-color: var(--blue-light); }
        .player-badge.yellow { background: var(--yellow); color: #333; border-color: var(--yellow-light); }
        .player-badge.green { background: var(--green); color: white; border-color: var(--green-light); }

        .crown {
            display: none;
        }

        .player-badge.active .crown {
            display: inline;
        }

        .board-wrapper {
            position: relative;
            padding: 15px;
            background: linear-gradient(145deg, #2d2d44, #1a1a2e);
            border-radius: 12px;
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(14, 1fr);
            grid-template-rows: repeat(14, 1fr);
            gap: 0;
            width: min(80vmin, 700px);
            height: min(80vmin, 700px);
            border: 3px solid var(--gold);
            border-radius: 4px;
            overflow: hidden;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 4vmin, 2.5rem);
            cursor: pointer;
            position: relative;
            transition: background-color 0.15s ease;
        }

        .cell.light { background-color: var(--board-light); }
        .cell.dark { background-color: var(--board-dark); }
        .cell.corner { background-color: transparent; pointer-events: none; }

        .cell.selected {
            background-color: var(--highlight) !important;
            box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: var(--valid-move);
            border-radius: 50%;
        }

        .cell.valid-capture {
            background-color: rgba(255, 100, 100, 0.4) !important;
        }

        .cell.last-move {
            box-shadow: inset 0 0 15px rgba(255, 255, 0, 0.3);
        }

        .piece {
            font-size: inherit;
            line-height: 1;
            transition: transform 0.1s ease;
            pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);
        }

        .piece.red { color: var(--red); }
        .piece.blue { color: var(--blue); }
        .piece.yellow { color: var(--yellow); }
        .piece.green { color: var(--green); }

        .cell:active .piece {
            transform: scale(1.15);
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            font-family: 'Cinzel', serif;
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: linear-gradient(145deg, var(--gold), #b8962e);
            color: #1a1a2e;
            font-weight: 700;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid var(--gold);
            text-align: center;
            z-index: 100;
            display: none;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .message h2 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .message p {
            color: #eee;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99;
            display: none;
        }

        .info {
            color: #888;
            font-size: 0.85rem;
            text-align: center;
            max-width: 400px;
        }

        @media (max-width: 600px) {
            .player-badge {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            
            .board {
                width: 90vmin;
                height: 90vmin;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>4-Player Chess</h1>
        
        <div class="turn-indicator">
            <div class="player-badge red" data-player="red">
                <span class="crown">&#9813;</span> Red
            </div>
            <div class="player-badge blue" data-player="blue">
                <span class="crown">&#9813;</span> Blue
            </div>
            <div class="player-badge yellow" data-player="yellow">
                <span class="crown">&#9813;</span> Yellow
            </div>
            <div class="player-badge green" data-player="green">
                <span class="crown">&#9813;</span> Green
            </div>
        </div>

        <div class="board-wrapper">
            <div class="board" id="board"></div>
        </div>

        <div class="controls">
            <button onclick="resetGame()">New Game</button>
            <button onclick="undoMove()">Undo</button>
        </div>

        <p class="info">Tap a piece to select, then tap a highlighted square to move. Capture all enemy kings to win!</p>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="message" id="message">
        <h2 id="messageTitle">Game Over</h2>
        <p id="messageText"></p>
        <button onclick="closeMessage()">Continue</button>
    </div>

    <script>
        // 4-Player Chess Game Logic
        const BOARD_SIZE = 14;
        const CORNER_SIZE = 3;
        
        // Player colors and their directions (which way pawns move)
        const PLAYERS = {
            red: { color: '#c0392b', direction: 1, symbol: 'R' },    // Top, moves down
            blue: { color: '#2980b9', direction: -1, symbol: 'B' },  // Right, moves left
            yellow: { color: '#f39c12', direction: -1, symbol: 'Y' }, // Bottom, moves up
            green: { color: '#27ae60', direction: 1, symbol: 'G' }   // Left, moves right
        };

        const TURN_ORDER = ['red', 'blue', 'yellow', 'green'];

        // Piece unicode characters with color variants
        const PIECES = {
            king: { white: '\u2654', black: '\u265A' },
            queen: { white: '\u2655', black: '\u265B' },
            rook: { white: '\u2656', black: '\u265C' },
            bishop: { white: '\u2657', black: '\u265D' },
            knight: { white: '\u2658', black: '\u265E' },
            pawn: { white: '\u2659', black: '\u265F' }
        };

        // Game state
        let board = [];
        let currentPlayer = 'red';
        let selectedCell = null;
        let validMoves = [];
        let moveHistory = [];
        let eliminatedPlayers = new Set();
        let lastMove = null;

        // Check if a position is in the corner (invalid area)
        function isCorner(row, col) {
            // Top-left corner
            if (row < CORNER_SIZE && col < CORNER_SIZE) return true;
            // Top-right corner
            if (row < CORNER_SIZE && col >= BOARD_SIZE - CORNER_SIZE) return true;
            // Bottom-left corner
            if (row >= BOARD_SIZE - CORNER_SIZE && col < CORNER_SIZE) return true;
            // Bottom-right corner
            if (row >= BOARD_SIZE - CORNER_SIZE && col >= BOARD_SIZE - CORNER_SIZE) return true;
            return false;
        }

        // Check if position is valid on board
        function isValidPosition(row, col) {
            return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE && !isCorner(row, col);
        }

        // Initialize the board with starting positions
        function initializeBoard() {
            board = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    board[row][col] = null;
                }
            }

            // Red pieces (top, rows 0-1, cols 3-10)
            const redBackRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                board[0][3 + i] = { type: redBackRow[i], player: 'red' };
                board[1][3 + i] = { type: 'pawn', player: 'red' };
            }

            // Yellow pieces (bottom, rows 12-13, cols 3-10)
            const yellowBackRow = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                board[13][3 + i] = { type: yellowBackRow[i], player: 'yellow' };
                board[12][3 + i] = { type: 'pawn', player: 'yellow' };
            }

            // Green pieces (left, cols 0-1, rows 3-10)
            const greenBackCol = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                board[3 + i][0] = { type: greenBackCol[i], player: 'green' };
                board[3 + i][1] = { type: 'pawn', player: 'green' };
            }

            // Blue pieces (right, cols 12-13, rows 3-10)
            const blueBackCol = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                board[3 + i][13] = { type: blueBackCol[i], player: 'blue' };
                board[3 + i][12] = { type: 'pawn', player: 'blue' };
            }
        }

        // Get piece symbol
        function getPieceSymbol(piece) {
            // Use white (filled) pieces for solid color appearance
            return PIECES[piece.type].white;
        }

        // Render the board
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    if (isCorner(row, col)) {
                        cell.classList.add('corner');
                    } else {
                        cell.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                        
                        const piece = board[row][col];
                        if (piece) {
                            const pieceEl = document.createElement('span');
                            pieceEl.className = `piece ${piece.player}`;
                            pieceEl.textContent = getPieceSymbol(piece);
                            cell.appendChild(pieceEl);
                        }

                        // Highlight selected cell
                        if (selectedCell && selectedCell.row === row && selectedCell.col === col) {
                            cell.classList.add('selected');
                        }

                        // Highlight valid moves
                        if (validMoves.some(m => m.row === row && m.col === col)) {
                            if (board[row][col]) {
                                cell.classList.add('valid-capture');
                            } else {
                                cell.classList.add('valid-move');
                            }
                        }

                        // Highlight last move
                        if (lastMove && ((lastMove.from.row === row && lastMove.from.col === col) ||
                            (lastMove.to.row === row && lastMove.to.col === col))) {
                            cell.classList.add('last-move');
                        }

                        cell.addEventListener('click', () => handleCellClick(row, col));
                        cell.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            handleCellClick(row, col);
                        });
                    }

                    boardEl.appendChild(cell);
                }
            }

            updateTurnIndicator();
        }

        // Update turn indicator
        function updateTurnIndicator() {
            document.querySelectorAll('.player-badge').forEach(badge => {
                const player = badge.dataset.player;
                badge.classList.remove('active');
                badge.classList.toggle('eliminated', eliminatedPlayers.has(player));
                if (player === currentPlayer && !eliminatedPlayers.has(player)) {
                    badge.classList.add('active');
                }
            });
        }

        // Get valid moves for a piece
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];

            const moves = [];
            const player = piece.player;

            switch (piece.type) {
                case 'pawn':
                    moves.push(...getPawnMoves(row, col, player));
                    break;
                case 'rook':
                    moves.push(...getSlidingMoves(row, col, player, [[0, 1], [0, -1], [1, 0], [-1, 0]]));
                    break;
                case 'bishop':
                    moves.push(...getSlidingMoves(row, col, player, [[1, 1], [1, -1], [-1, 1], [-1, -1]]));
                    break;
                case 'queen':
                    moves.push(...getSlidingMoves(row, col, player, [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]));
                    break;
                case 'king':
                    moves.push(...getKingMoves(row, col, player));
                    break;
                case 'knight':
                    moves.push(...getKnightMoves(row, col, player));
                    break;
            }

            return moves;
        }

        // Pawn moves (direction depends on player)
        function getPawnMoves(row, col, player) {
            const moves = [];
            let forwardDirs, captureDirs, startRows;

            // Define movement based on player position
            if (player === 'red') {
                forwardDirs = [[1, 0]];
                captureDirs = [[1, -1], [1, 1]];
                startRows = [1];
            } else if (player === 'yellow') {
                forwardDirs = [[-1, 0]];
                captureDirs = [[-1, -1], [-1, 1]];
                startRows = [12];
            } else if (player === 'green') {
                forwardDirs = [[0, 1]];
                captureDirs = [[-1, 1], [1, 1]];
                startRows = null; // Check column instead
            } else if (player === 'blue') {
                forwardDirs = [[0, -1]];
                captureDirs = [[-1, -1], [1, -1]];
                startRows = null;
            }

            // Forward move
            for (const [dr, dc] of forwardDirs) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol) && !board[newRow][newCol]) {
                    moves.push({ row: newRow, col: newCol });

                    // Double move from start
                    let canDouble = false;
                    if (player === 'red' && row === 1) canDouble = true;
                    if (player === 'yellow' && row === 12) canDouble = true;
                    if (player === 'green' && col === 1) canDouble = true;
                    if (player === 'blue' && col === 12) canDouble = true;

                    if (canDouble) {
                        const doubleRow = row + dr * 2;
                        const doubleCol = col + dc * 2;
                        if (isValidPosition(doubleRow, doubleCol) && !board[doubleRow][doubleCol]) {
                            moves.push({ row: doubleRow, col: doubleCol });
                        }
                    }
                }
            }

            // Captures
            for (const [dr, dc] of captureDirs) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol) && board[newRow][newCol] && board[newRow][newCol].player !== player) {
                    moves.push({ row: newRow, col: newCol });
                }
            }

            return moves;
        }

        // Sliding moves (rook, bishop, queen)
        function getSlidingMoves(row, col, player, directions) {
            const moves = [];
            for (const [dr, dc] of directions) {
                let newRow = row + dr;
                let newCol = col + dc;
                while (isValidPosition(newRow, newCol)) {
                    if (board[newRow][newCol]) {
                        if (board[newRow][newCol].player !== player) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                    moves.push({ row: newRow, col: newCol });
                    newRow += dr;
                    newCol += dc;
                }
            }
            return moves;
        }

        // King moves
        function getKingMoves(row, col, player) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol)) {
                    if (!board[newRow][newCol] || board[newRow][newCol].player !== player) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            return moves;
        }

        // Knight moves
        function getKnightMoves(row, col, player) {
            const moves = [];
            const offsets = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
            for (const [dr, dc] of offsets) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol)) {
                    if (!board[newRow][newCol] || board[newRow][newCol].player !== player) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            return moves;
        }

        // Handle cell click
        function handleCellClick(row, col) {
            const piece = board[row][col];

            // If clicking on own piece, select it
            if (piece && piece.player === currentPlayer && !eliminatedPlayers.has(currentPlayer)) {
                selectedCell = { row, col };
                validMoves = getValidMoves(row, col);
                renderBoard();
                return;
            }

            // If a piece is selected and clicking on valid move
            if (selectedCell && validMoves.some(m => m.row === row && m.col === col)) {
                makeMove(selectedCell.row, selectedCell.col, row, col);
                selectedCell = null;
                validMoves = [];
                renderBoard();
                return;
            }

            // Deselect
            selectedCell = null;
            validMoves = [];
            renderBoard();
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];

            // Save move for undo
            moveHistory.push({
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: { ...piece },
                captured: capturedPiece ? { ...capturedPiece } : null,
                player: currentPlayer
            });

            // Check for king capture
            if (capturedPiece && capturedPiece.type === 'king') {
                eliminatedPlayers.add(capturedPiece.player);
                showMessage(`${capturedPiece.player.charAt(0).toUpperCase() + capturedPiece.player.slice(1)} is eliminated!`, `Their king was captured by ${currentPlayer}.`);
                
                // Check for winner
                const activePlayers = TURN_ORDER.filter(p => !eliminatedPlayers.has(p));
                if (activePlayers.length === 1) {
                    setTimeout(() => {
                        showMessage(`${activePlayers[0].charAt(0).toUpperCase() + activePlayers[0].slice(1)} Wins!`, 'Congratulations on your victory!');
                    }, 1500);
                }
            }

            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;

            // Pawn promotion
            if (piece.type === 'pawn') {
                let promote = false;
                if (piece.player === 'red' && toRow === 13) promote = true;
                if (piece.player === 'yellow' && toRow === 0) promote = true;
                if (piece.player === 'green' && toCol === 13) promote = true;
                if (piece.player === 'blue' && toCol === 0) promote = true;
                
                if (promote) {
                    board[toRow][toCol].type = 'queen';
                }
            }

            lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };

            // Next player
            nextTurn();
        }

        // Move to next turn
        function nextTurn() {
            let nextIndex = (TURN_ORDER.indexOf(currentPlayer) + 1) % 4;
            let attempts = 0;
            
            while (eliminatedPlayers.has(TURN_ORDER[nextIndex]) && attempts < 4) {
                nextIndex = (nextIndex + 1) % 4;
                attempts++;
            }
            
            currentPlayer = TURN_ORDER[nextIndex];
        }

        // Undo last move
        function undoMove() {
            if (moveHistory.length === 0) return;

            const lastMoveData = moveHistory.pop();
            
            // Restore piece
            board[lastMoveData.from.row][lastMoveData.from.col] = lastMoveData.piece;
            board[lastMoveData.to.row][lastMoveData.to.col] = lastMoveData.captured;

            // Restore eliminated player if king was captured
            if (lastMoveData.captured && lastMoveData.captured.type === 'king') {
                eliminatedPlayers.delete(lastMoveData.captured.player);
            }

            currentPlayer = lastMoveData.player;
            selectedCell = null;
            validMoves = [];
            
            // Update last move indicator
            if (moveHistory.length > 0) {
                const prev = moveHistory[moveHistory.length - 1];
                lastMove = { from: prev.from, to: prev.to };
            } else {
                lastMove = null;
            }

            renderBoard();
        }

        // Show message
        function showMessage(title, text) {
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            document.getElementById('message').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }

        // Close message
        function closeMessage() {
            document.getElementById('message').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // Reset game
        function resetGame() {
            currentPlayer = 'red';
            selectedCell = null;
            validMoves = [];
            moveHistory = [];
            eliminatedPlayers.clear();
            lastMove = null;
            initializeBoard();
            renderBoard();
        }

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.board')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Initialize
        resetGame();
    </script>
</body>
</html>
